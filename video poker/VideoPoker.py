import numpy as np
from Deck import deck
from CheckScore import jacks_or_better_scorer
import warnings
warnings.filterwarnings("ignore", category=np.VisibleDeprecationWarning)


def combinations(lst, depth, start=0, prepend=[]):
    """
        This function yields all the possible combinations
        of cards in hand.
    """

    if depth <= 0:
        yield prepend
    else:
        for i in range(start, len(lst)):
            for combi in combinations(lst, depth-1, i+1, prepend+[lst[i]]):
                yield combi


def play_poker(money=20, sim_strength=1000, max_count=10000, return_count=False, return_both=False, verbose=False):
    """
        This function plays max_count=10000 games of poker or up until the player has no more money
        During each game the all the possible combinations of the hand are calculated.
        And a sim_strength=1000 simulations are run for each combination to calculate the expected winnings.
        The hand with the highest expected winnings is designated the best move and that hand is used to play a game.
        The result (winnings) of that game is added to the total amount money the player has.
        Another game is played of count is less than max_count=10000 and the player hasn't run out of money
    """
    # money = 20
    money_tally = [money]
    count = 0

    # Checks to see if we have enough money to play
    # And checks to see that game hasn't run for too long
    while money > 0 and count < max_count:
        # bets 1 dollar  per hand and counts total number hands played  before money runs out
        count += 1
        money -= 1

        cards = deck()
        cards.shuffle()
        cards.deal_five()
        possible_hold_combos = [[]]

        # all the possible combinations of cards in a hand are stored in possible_hold_combos
        for i in range(1, 6):
            for c in combinations([0, 1, 2, 3, 4], i):
                possible_hold_combos.append(c)

        # Set up results checker
        raw_score = {}
        results = []
        for c in possible_hold_combos:
            raw_score[str(c)] = []

        # For each card combination, run the simulation a thousand times. Append results of each sim to raw_score
        # For each card combination, draw new cards randomly by setting shuffle_remaining=True
        for combo in possible_hold_combos:
            for i in range(sim_strength):
                cards.draw_cards(ids_to_hold=combo, shuffle_remaining=True)
                jb = jacks_or_better_scorer(cards.final_hand)
                raw_score[str(combo)].append(jb.score)

        # Find the mean score for each combination of cards. Append to results
        for key, value in raw_score.items():
            results.append((key, np.mean(value)))

        # Identify the best combination of cards to play on average
        best_move = eval(sorted(results, key=lambda x: x[1], reverse=True)[0][0])

        # Play with best hand (statistically) and calculate score and winnings
        cards.draw_cards(ids_to_hold=best_move, shuffle_remaining=True)
        winnings = jacks_or_better_scorer(cards.final_hand).score

        # Add winnings, if any, wallet
        money += winnings
        money_tally.append(money)

        # for every 10 games print hand and amount of money in the wallet
        if count % 10 == 0 and verbose:
            print("Hand %i, Money: %i" % (count, money))

    # return total number of games played and amount of money won on each game
    if return_both:
        return count, money_tally
    elif return_count:
        return count
    else:
        return money_tally


def play_poker_randomly(money, max_count=10000, return_count=False, verbose=False):
    """
        This function plays max_count=10000 games of poker or up until the player has no more money
        During each game the all the possible combinations of the hand are calculated.
        From these combinations one is selected randomly.
        This randomly selected hand is used to play the game.
        The winnings generated by that hand is calculated and is added to the total amount money the player has.
        Another game is played of count is less than max_count=10000 and the player hasn't run out of money
      """
    #money = 20
    money_tally = [money]
    count = 0

    while money > 0 and count < max_count:
        count += 1
        money -= 1
        cards = deck()
        cards.shuffle()
        cards.deal_five()
        possible_hold_combos = [[]]

        for i in range(1, 6):
            for c in combinations([0, 1, 2, 3, 4], i):
                possible_hold_combos.append(c)

        cards.draw_cards(ids_to_hold=np.random.choice(possible_hold_combos), shuffle_remaining=True)
        winnings = jacks_or_better_scorer(cards.final_hand).score
        money += winnings
        money_tally.append(money)

        if count%10 == 0 and verbose:
            print("Hand %i, Money: %i" %(count, money))
    if return_count:
        return count
    else:
        return money_tally





'''money_tally= play_poker(20, sim_strength=100, verbose=True)
plt.figure(dpi=100)
max_len = len(money_tally)
plt.plot(range(max_len), money_tally);
plt.plot([0, max_len], [20,20], 'r--', lw=2, alpha=0.5)
plt.xlabel("Number of Hands")
plt.ylabel("Amount of Money")
plt.show();'''

